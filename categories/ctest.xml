<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Journey to the Center of the Computer (ctest)</title><link>https://markdewing.github.io/blog/</link><description></description><atom:link href="https://markdewing.github.io/blog/categories/ctest.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Fri, 19 Feb 2016 23:06:21 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Notes on CMake</title><link>https://markdewing.github.io/blog/posts/notes-on-cmake/</link><dc:creator>Mark Dewing</dc:creator><description>&lt;div&gt;&lt;p&gt;Recently I started working on a project that uses CMake.  I've used CMake a little before, but never really
had to dive much into it.
In particular, I needed to understand the scripting parts of CMake for adding tests for CTest.&lt;/p&gt;
&lt;p&gt;Below are some comments on aspects of CMake.&lt;/p&gt;
&lt;h3&gt;Variables and variable substitution&lt;/h3&gt;
&lt;p&gt;Variables names are strings.  Substitution occurs when the variable is dereferenced with &lt;code&gt;${}&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nb"&gt;SET&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;var,&lt;/span&gt; &lt;span class="s"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;MESSAGE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"var = ${var}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;produces&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Nested substitutions are possible&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nb"&gt;SET&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;var,&lt;/span&gt; &lt;span class="s"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;SET&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;a,&lt;/span&gt; &lt;span class="s"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;MESSAGE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"var = ${var}  ${${var}}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;will produce 
&lt;code&gt;var = a b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Variable names can be composed during substitution&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nb"&gt;SET&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;var,&lt;/span&gt; &lt;span class="s"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;SET&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;a_one,&lt;/span&gt; &lt;span class="s"&gt;apple&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;MESSAGE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"var =  ${${var}_one}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;will produce &lt;code&gt;var = apple&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Variables and functions&lt;/h3&gt;
&lt;p&gt;Variable references act a little like pointers, but without a type system to enforce (and guide) how many indirections should be performed.&lt;/p&gt;
&lt;p&gt;Example of using a variable inside a function:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nb"&gt;FUNCTION&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;MY_FUNC&lt;/span&gt; &lt;span class="s"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;MESSAGE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"arg1 = ${arg1}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;ENDFUNCTION&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="nb"&gt;MY_FUNC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;SET&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;var,&lt;/span&gt; &lt;span class="s"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;MY_FUNC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;var&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# arg1 is set to 'var'&lt;/span&gt;
&lt;span class="nb"&gt;MY_FUNC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# arg1 is set to 'a' - this is usually what you want&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;produces&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;
&lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;


&lt;h3&gt;Return values from functions&lt;/h3&gt;
&lt;p&gt;There is no built-in notion of a return value from a function.   To get values out of a function, write to one of the arguments.&lt;/p&gt;
&lt;p&gt;A function creates a new scope - changes to a variable will only affect the variable's value 
inside the function.  To affect the value in the parent, the &lt;code&gt;PARENT_SCOPE&lt;/code&gt; modifier should be given to the &lt;code&gt;SET&lt;/code&gt; command.  (More on variable scopes &lt;a href="https://www.johnlamp.net/cmake-tutorial-5-functionally-improved-testing.html"&gt;here&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Another issue is the variable name for the output value needs to be dereferenced before being set.
Otherwise a variable with the name used in the function will be set in the parent, which can work by accident
if the variables have the same name.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nb"&gt;FUNCTION&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;MY_FUNC_WITH_RET&lt;/span&gt; &lt;span class="s"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c"&gt;# The following line works by accident if the name of variable in the parent&lt;/span&gt;
    &lt;span class="c"&gt;# is the same as in the function&lt;/span&gt;
    &lt;span class="nb"&gt;SET&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;ret&lt;/span&gt; &lt;span class="s2"&gt;"in function"&lt;/span&gt; &lt;span class="s"&gt;PARENT_SCOPE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c"&gt;# This is the correct way to get the variable name passed to the function&lt;/span&gt;
    &lt;span class="nb"&gt;SET&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;ret&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="s2"&gt;"in function"&lt;/span&gt; &lt;span class="s"&gt;PARENT_SCOPE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;ENDFUNCTION&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="nb"&gt;SET&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;ret&lt;/span&gt; &lt;span class="s2"&gt;"before function"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;MY_FUNC_WITH_RET&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;MESSAGE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"output from function = ${ret}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;will produce &lt;code&gt;output from function = in function&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Data structures&lt;/h3&gt;
&lt;p&gt;There is only the List type, with some functions for operations on lists.
The &lt;a href="https://cmake.org/cmake/help/v3.3/manual/cmake-language.7.html#lists"&gt;documentation on lists&lt;/a&gt; says that "Lists ... should not be used for complex data processing tasks", but doesn't say what to use instead.&lt;/p&gt;
&lt;p&gt;For associative arrays or maps there are some options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Two parallel lists - one of keys and one of values.  Search the key list and use the index to look up value.  More awkward for passing to functions.&lt;/li&gt;
&lt;li&gt;Single list with alternating keys and values.  Search the list for the key, and use index+1 to look up the value.  Only works if the range of possibilities for keys and values are distinct (e.g., keys are strings and values are always numbers).&lt;/li&gt;
&lt;li&gt;The environment (&lt;code&gt;ENV{key}&lt;/code&gt;) is a built-in associative array.  It could be overloaded to store other values, at the risk of polluting the environment.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Test timeout&lt;/h3&gt;
&lt;p&gt;The default timeout per test is 1500 seconds (25 minutes).&lt;/p&gt;
&lt;p&gt;To increase this, adjust the value of &lt;code&gt;DART_TESTING_TIMEOUT&lt;/code&gt;.
It needs to be set as a cache variable, and it needs to be set before the &lt;code&gt;enable_testing()&lt;/code&gt; or &lt;code&gt;include(CTest)&lt;/code&gt; is specified.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nb"&gt;SET&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;DART_TESTING_TIMEOUT&lt;/span&gt; &lt;span class="s"&gt;3600&lt;/span&gt; &lt;span class="s"&gt;CACHE&lt;/span&gt; &lt;span class="s"&gt;STRING&lt;/span&gt; &lt;span class="s2"&gt;"Maximum time for one test"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;See also this &lt;a href="http://stackoverflow.com/questions/3545598/using-cmake-with-ctest-and-cdash"&gt;Stack Overflow post&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>cmake</category><category>ctest</category><guid>https://markdewing.github.io/blog/posts/notes-on-cmake/</guid><pubDate>Fri, 19 Feb 2016 11:05:00 GMT</pubDate></item></channel></rss>