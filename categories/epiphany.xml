<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Journey to the Center of the Computer (Posts about epiphany)</title><link>https://markdewing.github.io/blog/</link><description></description><atom:link href="https://markdewing.github.io/blog/categories/epiphany.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Sun, 18 Jun 2023 17:08:31 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Building A Parallella Cluster</title><link>https://markdewing.github.io/blog/posts/building-a-parallella-cluster/</link><dc:creator>Mark Dewing</dc:creator><description>&lt;p&gt;I finally got around to assembling my small pile of Parallella boards into a cluster.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://markdewing.github.io/blog/2016/parallella_cluster_side_top_lg.jpg"&gt;&lt;img alt="Alternate side view" src="https://markdewing.github.io/blog/2016/parallella_cluster_side_top_sm3.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This post documents the choices I made about power distribution, mechanical assembly, cooling, software management, etc.
For background on the individual boards, see my previous post:
&lt;a href="https://markdewing.github.io/blog/posts/introduction-to-parallella/"&gt;Introduction to Parallella&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The software directions are based on the Linaro 14.04 image.
(At some point I should upgrade to the latest Paraubuntu release.)&lt;/p&gt;
&lt;h3&gt;Power&lt;/h3&gt;
&lt;p&gt;There are several options for powering multiple boards:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Solder a jumper and use the mounting pads with metal standoffs to transmit the power.  This option requires the fewest cords.&lt;/li&gt;
&lt;li&gt;Use micro USB connector (need to switch jumper J14).  There are multi-port USB power supplies that should work.  This is probably the simplest option for a small number of boards.&lt;/li&gt;
&lt;li&gt;Use the 5.5mm barrel plug (default settings).  There are versions with screw terminals on Amazon (&lt;a href="https://www.amazon.com/gp/product/B00VESYK0S/"&gt;these&lt;/a&gt; for example).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I went with option 3 and used an old PC power supply for the power.&lt;/p&gt;
&lt;h3&gt;Mechanical assembly&lt;/h3&gt;
&lt;p&gt;I used &lt;a href="https://www.amazon.com/gp/product/B013G1Q300/"&gt;20mm nylon standoffs&lt;/a&gt; and assembled the boards into two stacks.
A small piece of 1/4" plywood was used for the base.&lt;/p&gt;
&lt;h3&gt;Cooling&lt;/h3&gt;
&lt;p&gt;For air flow, I used a cooling fan from an old PC and mounted it to the plywood base.&lt;/p&gt;
&lt;h3&gt;Network&lt;/h3&gt;
&lt;p&gt;Needing ports for a maximum of 10 boards, plus one port for the external connection, I chose a &lt;a href="https://www.amazon.com/gp/product/B0092KZBCQ/"&gt;16-port Gigabit D-Link switch&lt;/a&gt;.
Eventually I would like to power the network switch from the PC power supply, but need to get the right plug first.&lt;/p&gt;
&lt;p&gt;The nodes use DHCP from my home network get their addresses.
A future improvement is to run a DHCP server on one node and use that to supply addresses to the other nodes.
This would make the cluster independent of running on my home network.&lt;/p&gt;
&lt;h3&gt;MicroSD cards&lt;/h3&gt;
&lt;p&gt;Follow the directions on the Parallella &lt;a href="http://www.parallella.org/create-sdcard/"&gt;Create SD Card&lt;/a&gt; page.
After burning the image, use &lt;code&gt;gparted&lt;/code&gt; to resize the partition to the full capacity of the card.&lt;/p&gt;
&lt;h3&gt;Management and control&lt;/h3&gt;
&lt;p&gt;Performing software installs and other management on all of boards individually would be too tedious.
There are many solutions for managing clusters.
I decided to use &lt;a href="http://docs.ansible.com/ansible/intro_getting_started.html"&gt;Ansible&lt;/a&gt;, as it seemed the simplest (no software needed on nodes) and it runs over ssh.&lt;/p&gt;
&lt;p&gt;In addition to controlling operations from a PC, it is useful to designate one node as a 'head node' and install Ansible there as well.
For MPI, it's easier to run MPI programs from the head node than from the PC.
For setting up configuration files, it can be useful to create or edit the file and make sure it works on one node, and then copy the file to all the other nodes.&lt;/p&gt;
&lt;p&gt;Ansible and MPI (and general convenience) require setting up &lt;a href="http://www.tecmint.com/ssh-passwordless-login-using-ssh-keygen-in-5-easy-steps/"&gt;passwordless ssh login&lt;/a&gt;.&lt;/p&gt;
&lt;!--Some directions to set up [ssh passwordless login](http://www.tecmint.com/ssh-passwordless-login-using-ssh-keygen-in-5-easy-steps/)--&gt;

&lt;p&gt;Once the keys are set up locally, you can use &lt;code&gt;ssh-copy-id&lt;/code&gt; to copy the credentials.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;copy&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;id_rsa&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pub&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;parallella&lt;/span&gt;&lt;span class="mf"&gt;@10.0.0.145&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I keep a small script that puts this line in the history (named &lt;code&gt;ssh_copy_id&lt;/code&gt;)&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;history&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"ssh-copy-id -i ~/.ssh/id_rsa.pub parallella@10.0.0.145"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Run the command &lt;code&gt;source ssh_copy_id&lt;/code&gt; to put the command on the history list.
Use the bash history and line editing features to select the command and update to a new address.&lt;/p&gt;
&lt;p&gt;Rather than create a new user, I'm using the default 'parallella' user on the nodes.
The SSH config (in '.ssh/config') can be set up to switch users upon login.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;Host 10.0.0.127
    User parallella
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You might wish to &lt;a href="http://www.tecmint.com/apt-cache-server-in-ubuntu/"&gt;set up a apt-cache server&lt;/a&gt; on a local machine to save on download bandwidth when installing software to all the nodes.&lt;/p&gt;
&lt;!--[Some directions here](http://www.tecmint.com/apt-cache-server-in-ubuntu/)--&gt;

&lt;h4&gt;Using Ansible&lt;/h4&gt;
&lt;p&gt;See the &lt;a href="http://docs.ansible.com/ansible/intro_getting_started.html"&gt;intro docs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The inventory file is a list of IP addresses (one per line).     It can be specified on the command line
with `-i'.  To see if all the nodes work&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ansible -i cluster.ini all -m ping
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;To copy the apt-cache server configuration to all the nodes, use&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt; ansible -i hosts all --sudo -m copy -a "src=/etc/apt/apt.conf.d/02proxy dest=/etc/apt/apt.conf.d/02proxy"
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;To shutdown all the nodes, use&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ansible -i cluster.ini all --sudo -m shell -a "shutdown now"
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Compilation&lt;/h3&gt;
&lt;p&gt;In the &lt;a href="https://markdewing.github.io/blog/posts/introduction-to-parallella/"&gt;introductory post&lt;/a&gt; I talked about cross compiling for the board.
That gets more complicated with larger software packages.
For instance, one of my project dependencies, HDF, doesn't cross-compile easily (or at all). &lt;/p&gt;
&lt;p&gt;Since the nodes use a regular Ubuntu distribution, native compilation is easy, but slow.&lt;/p&gt;
&lt;p&gt;One solution is to use &lt;a href="https://github.com/distcc/distcc"&gt;distcc&lt;/a&gt;.  &lt;/p&gt;
&lt;p&gt;The particular software package I'm working with (QMCPACK, which does simulations on atoms, molecules, and solids)
uses CMake for configuration and build, and builds fine with distcc.&lt;/p&gt;
&lt;p&gt;Install on all nodes with &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;ansible -i cluster.ini all --sudo  -a "apt-get install -y distcc"
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Set the &lt;code&gt;DISTCC_HOSTS&lt;/code&gt; variable to the set of systems to use&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;export&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DISTCC_HOSTS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"localhost @10.0.0.144/2 @10.0.0.145/2"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This example shows three hosts. The initial '@' means to use ssh (no daemon required on remote) and the '/2' on the end means to use two threads.&lt;/p&gt;
&lt;p&gt;Now set the C and C++ compilers to &lt;code&gt;distcc &amp;lt;compiler&amp;gt;&lt;/code&gt; and run the build.&lt;/p&gt;
&lt;p&gt;For CMake, building a project with MPI, this is&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;export&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CC&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"distcc mpicc"&lt;/span&gt;
&lt;span class="k"&gt;export&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CXX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"distcc mpic++"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Then&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;make -j 8
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You might see an warning message &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;distccd[&amp;lt;pid&amp;gt;] (tcp_cork_sock) Warning: setsockopt(corked=1) failed: Socket operation on non-socket
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This can be ignored.  Or follow some directions to &lt;a href="https://jeffreywildman.wordpress.com/2011/02/11/disable-tcp_cork_sock-warnings-when-using-distcc-over-ssh/"&gt;silence it&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;MPI&lt;/h3&gt;
&lt;p&gt;One popular method for writing programs that communicate across the boards is &lt;a href="https://computing.llnl.gov/tutorials/mpi/"&gt;MPI (Message Passing Interface)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Install the 'mpi-default-dev' package (which should also install the 'mpi-default-bin' package).
This installs the Open MPI implementation (the alternative being MPICH).
Note that this MPI is only concerned with communication between the ARM cores on different boards.
There is also the Brown Deer Technology version of MPI for programming the Epiphany accelerator.&lt;/p&gt;
&lt;p&gt;It's common to use a networked file system so each local node has access to the executables and input files.
Ansible has file distribution commands that work well enough that a networked file system isn't strictly necessary.
(Be aware when copying directories with Ansible that if the directory specified in &lt;code&gt;src&lt;/code&gt; does not end with '/', the directory and it's contents are copied.  If it does end with '/', just the directory contents are copied.)&lt;/p&gt;
&lt;p&gt;Open MPI uses a tree-based launcher for better scalable start-up performance.  Because of this, each node should
be able to log into each other node (not just head node to other nodes).&lt;/p&gt;
&lt;p&gt;MPI needs a list of machines to run on.  One method is to create a host file and pass it to &lt;code&gt;mpirun&lt;/code&gt; with the &lt;code&gt;--hostfile&lt;/code&gt; option.  The host file, at its simplest, is one hostname or IP address per line (same as a simple Ansible inventory file.)&lt;/p&gt;
&lt;h3&gt;Gallery&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://markdewing.github.io/blog/2016/parallella_cluster_front_side_lg.jpg"&gt;&lt;img alt="Front/side view" src="https://markdewing.github.io/blog/2016/parallella_cluster_front_side_sm2.jpg"&gt;&lt;/a&gt;    
&lt;a href="https://markdewing.github.io/blog/2016/parallella_cluster_back_view_lg.jpg"&gt;&lt;img alt="Back view" src="https://markdewing.github.io/blog/2016/parallella_cluster_back_view_sm2.jpg"&gt;&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href="https://markdewing.github.io/blog/2016/parallella_cluster_side_lg.jpg"&gt;&lt;img alt="Side view" src="https://markdewing.github.io/blog/2016/parallella_cluster_side_sm2.jpg"&gt;&lt;/a&gt;   
&lt;a href="https://markdewing.github.io/blog/2016/parallella_cluster_top_lg.jpg"&gt;&lt;img alt="Top view" src="https://markdewing.github.io/blog/2016/parallella_cluster_top_sm2.jpg"&gt;&lt;/a&gt;  
&lt;a href="https://markdewing.github.io/blog/2016/parallella_cluster_side_top_lg.jpg"&gt;&lt;img alt="Alternate side view" src="https://markdewing.github.io/blog/2016/parallella_cluster_side_top_sm3.jpg"&gt;&lt;/a&gt;&lt;/p&gt;</description><category>Ansible</category><category>epiphany</category><category>MPI</category><category>parallella</category><category>zynq</category><guid>https://markdewing.github.io/blog/posts/building-a-parallella-cluster/</guid><pubDate>Tue, 03 Jan 2017 01:56:00 GMT</pubDate></item><item><title>Running Programs on Epiphany</title><link>https://markdewing.github.io/blog/posts/running-programs-on-epiphany/</link><dc:creator>Mark Dewing</dc:creator><description>&lt;p&gt;In the &lt;a href="https://markdewing.github.io/blog/posts/communicating-with-epiphany/index.html"&gt;last post&lt;/a&gt;, we looked at the memory layout and ran a simple demo.
Let's take a closer look at how a program starts running.&lt;/p&gt;
&lt;p&gt;For starters, compile and run the program from last time.  We're going to run the program again, this time manually using the low-level mechanism that &lt;code&gt;e-loader&lt;/code&gt; uses to start programs.&lt;/p&gt;
&lt;p&gt;Writing a 1 (SYNC) value to the ILATST register will trigger the Sync interrupt, and cause an existing program to run on the core.&lt;/p&gt;
&lt;p&gt;Remember that the registers from each core are memory mapped to the host.
The register addresses are defined in &lt;code&gt;/opt/adapteva/esdk/tools/host/include/epiphany-hal-data.h&lt;/code&gt;.
We want E_REG_ILATST, which is 0xf042C.&lt;/p&gt;
&lt;p&gt;To see if this works, change the input values.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;parallella&lt;/span&gt;&lt;span class="nv"&gt;@parallella&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;write&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00002000&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000004&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00002004&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000005&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00002008&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now, write the ILATST register to run the program&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;parallella&lt;/span&gt;&lt;span class="nv"&gt;@parallella&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;write&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xf042c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And check the result&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;parallella&lt;/span&gt;&lt;span class="nv"&gt;@parallella&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;read&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x2000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00002000&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000004&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00002004&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000005&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00002008&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000009&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It worked!&lt;/p&gt;
&lt;p&gt;Okay, now let's look at the details of what happened.&lt;/p&gt;
&lt;p&gt;The first 40 bytes of the core-local memory are reserved for the Interrupt Vector Table (IVT).
Each entry is 4 bytes long, and should contain a jump (branch) instruction to the desired code.
The first entry in the table is the Sync interrupt, used to start the program.
(See the &lt;a href="http://adapteva.com/docs/epiphany_arch_ref.pdf"&gt;Epiphany Architecture Reference&lt;/a&gt; for the rest of the IVT entries)&lt;/p&gt;
&lt;p&gt;We can disassemble the compiled object file with &lt;code&gt;e-objdump -D&lt;/code&gt; and look for address 0 
(we need -D instead of -d to disassemble all the sections, not just the normal executable sections).&lt;/p&gt;
&lt;p&gt;This looks promising.  Address of 0, in a section called &lt;code&gt;ivt_reset&lt;/code&gt;.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;Disassembly of section ivt_reset:

00000000 &amp;lt;_start&amp;gt;:
   0:   2ce8 0000       b 58 &amp;lt;.normal_start&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;After the Sync interrupt, control transfers to address 0, and then branches to location 0x58.
The next section in the objdump output has that address.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;Disassembly of section .reserved_crt0:

00000058 &amp;lt;.normal_start&amp;gt;:
  58:   720b 0002       mov r3,0x90
  5c:   600b 1002       movt r3,0x0
  60:   0d52            jalr r3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This loads address 0x90 and jumps to it.
The &lt;code&gt;mov&lt;/code&gt; instruction loads the lower 16 bits of r3 and the &lt;code&gt;movt&lt;/code&gt; instruction loads the upper 16 bits.&lt;/p&gt;
&lt;p&gt;Now look for that address&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;Disassembly of section .text:

00000090 &amp;lt;_epiphany_start&amp;gt;:
  90:   be0b 27f2       mov sp,0x7ff0
  94:   a00b 3002       movt sp,0x0

   ... 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This sets up the stack by loading the stack pointer with 0x7ff0, which is the top of the 32K local address space.
The code calls other routines, which eventually call &lt;code&gt;main&lt;/code&gt;, but I won't trace it all here.&lt;/p&gt;</description><category>epiphany</category><category>parallella</category><guid>https://markdewing.github.io/blog/posts/running-programs-on-epiphany/</guid><pubDate>Tue, 01 Sep 2015 18:13:00 GMT</pubDate></item><item><title>Communicating with Epiphany</title><link>https://markdewing.github.io/blog/posts/communicating-with-epiphany/</link><dc:creator>Mark Dewing</dc:creator><description>&lt;p&gt;This post is going to look at the Epiphany memory map, and give a very simple example demonstration.
I will skim over some background information that is covered elsewhere.
See the following posts and resources that describe the Parallella and Epiphany architectures.&lt;/p&gt;
&lt;h3&gt;Resources&lt;/h3&gt;
&lt;p&gt;Parallella Chronicles&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.parallella.org/2014/11/25/parallella-chronicles-part-one-2/"&gt;Part One: Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.parallella.org/2014/12/15/parallella-chronicles-part-two-2/"&gt;Part Two: The Software Development Kit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.parallella.org/2015/01/14/parallella-chronicles-part-three/"&gt;Part Three: "Hello World"&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.parallella.org/2015/02/28/parallella-chronicles-part-five/"&gt;Part Five: The Epiphany Memory Map&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Technical Musings&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://suzannejmatthews.github.io/2015/06/02/epiphany-overview/"&gt;Overview of Epiphany Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://suzannejmatthews.github.io/2015/06/03/epiphany-hello-world/"&gt;Hello Epiphany&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Manuals&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://adapteva.com/docs/epiphany_arch_ref.pdf"&gt;Epiphany Architecture Reference Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://adapteva.com/docs/epiphany_sdk_ref.pdf"&gt;Epiphany SDK Reference Manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Source code&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/adapteva/epiphany-libs"&gt;epiphany-libs&lt;/a&gt; repo on github with the e-hal and various utilities.
The epiphany-sdk repo contains download and build script for the GNU toolchain.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post is going to be written from the perspective of a PC programmer.
Desktop operating systems use virtual memory, and programmers don't have to think about hardware addresses very much. 
The relative addresses inside each process matter most.
Many of the addresses on the Epiphany are fixed, or fixed relative to each core, and require more 'hard-coding' of addresses.
Although most of that is accomplished through the toolchain, it is useful to understand when programming the board.
(Programmers of embedded systems are more used to this sort of memory layout control.)&lt;/p&gt;
&lt;h3&gt;Memory Layout&lt;/h3&gt;
&lt;p&gt;The Epiphany contains onboard RAM (32K per core). This called 'local' or 'core-local' memory, and is the fastest to access.&lt;/p&gt;
&lt;p&gt;There is a larger section of memory (32MB) that is reserved from top of the SDRAM and shared with the Epiphany.
This is called 'external memory' from the perspective of the Epiphany.  It's also called 'shared memory'.
It is much slower to access from the Epiphany.&lt;/p&gt;
&lt;p&gt;The shared memory and memory locations inside the chip are both mapped in the address space of the host, and can be access by the host.
Locations in the chip include&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32K local to each core&lt;/li&gt;
&lt;li&gt;Registers on each core&lt;/li&gt;
&lt;li&gt;Chip-wide registers &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Something interesting here is that the registers all have memory mappings.
That means the registers can be accessed by the host (and other cores) by simply reading or writing a specific memory location.
(It is important to note that register values are only valid when the core is halted.)&lt;/p&gt;
&lt;h3&gt;Epiphany Software Development Kit&lt;/h3&gt;
&lt;p&gt;The ESDK contains some utilities to access these memory regions from the command line.
The commands &lt;code&gt;e-read&lt;/code&gt; and &lt;code&gt;e-write&lt;/code&gt; are used to read and write the locations.
To access the core-local memory, use row/column coordinate of the core (0-3 for each), followed by the offset.
For reading, optionally add the number of 4-byte words to read.  For writing, give a list of 4-byte word values.&lt;/p&gt;
&lt;p&gt;For example, to read 8 bytes from core (0,0)&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;parallella&lt;/span&gt;&lt;span class="nv"&gt;@parallella&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;read&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x100&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00000100&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x782de028&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00000104&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x0d906c89&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;To access the external memory, use a single -1 instead of the row,col coordinates.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;parallella&lt;/span&gt;&lt;span class="nv"&gt;@parallella&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;write&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00000000&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000001&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00000004&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000002&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00000008&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000003&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Upon power up, it appears the memory is filled with random values.
The &lt;code&gt;epiphany-examples&lt;/code&gt; directory contains some useful utilities in the &lt;code&gt;apps&lt;/code&gt; directory.
To fill memory with some values, use &lt;code&gt;e-fill-mem&lt;/code&gt; (build it by running the &lt;code&gt;build.sh&lt;/code&gt; script first)&lt;/p&gt;
&lt;p&gt;To zero all the local memory in core 0, 0:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;parallella&lt;/span&gt;&lt;span class="nv"&gt;@parallella&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="n"&gt;epiphany&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;examples&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;apps&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;fill&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;fill&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;elf&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8192&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Verify a few locations&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;parallella&lt;/span&gt;&lt;span class="nv"&gt;@parallella&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="n"&gt;epiphany&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;examples&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;apps&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;fill&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;read&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00000000&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000000&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00000004&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000000&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00000008&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000000&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x0000000c&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Nostalgia sidebar: If you want to reminisce about the days of Commodore 64, Apple II's and other microcomputers, alias &lt;code&gt;e-read&lt;/code&gt; and &lt;code&gt;e-write&lt;/code&gt; to &lt;code&gt;peek&lt;/code&gt; and &lt;code&gt;poke&lt;/code&gt;. (For the bash shell that would be &lt;code&gt;alias peek=e-read&lt;/code&gt; and &lt;code&gt;alias poke=e-write&lt;/code&gt;)&lt;/p&gt;
&lt;h3&gt;Simple example of local memory access&lt;/h3&gt;
&lt;p&gt;To solidify understanding of how this works, let's try a simple program that adds two numbers in core-local memory,
and saves the result to another location in core-local memory.  We will use the command line tools to set memory and verify
the operation. &lt;/p&gt;
&lt;p&gt;The 32KB of local memory puts all the offsets in the range 0x0000 - 0x8000.   Let's choose a base location 0x2000, which will be above the executable code, and below the stack.&lt;/p&gt;
&lt;p&gt;Start with the following C program (mem.c)&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="c1"&gt;// Demonstrate local memory access at a low level&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Location in local memory will not interfere&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// with the executable or the stack&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;outbuf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mh"&gt;0x2000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;outbuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;outbuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;outbuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Compile with &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;e-gcc mem.c -T /opt/adapteva/esdk/bsps/current/fast.ldf -o mem.elf
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The -T option refers to a linker script, which controls where various pieces of the executable are placed in memory.&lt;/p&gt;
&lt;p&gt;Set the initial memory locations&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;parallella&lt;/span&gt;&lt;span class="nv"&gt;@parallella&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;write&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x2000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00002000&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000001&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00002004&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000002&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00002008&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Load and run the program (the -s option to e-loader runs the program after loading)&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;parallella&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;parallella&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;~$&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;loader&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;elf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="n"&gt;Loading&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"mem.elf"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cores&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;e_set_loader_verbosity&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;setting&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;loader&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;verbosity&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;
&lt;span class="n"&gt;e_load_group&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;loading&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ELF&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;elf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;e_load_group&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SYNC&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;core&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;e_start&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SYNC&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0xf042c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;core&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;e_start&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;done&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;e_load_group&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;done&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;e_load_group&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;done&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;loading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;e_load_group&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;closed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;connection&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;e_load_group&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;leaving&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;loader&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now verify the program produced the expected result:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;parallella&lt;/span&gt;&lt;span class="nv"&gt;@parallella&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;read&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x2000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00002000&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000001&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00002004&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000002&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0x00002008&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x00000003&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Yes.  It worked!&lt;/p&gt;
&lt;p&gt;Now we've seen some concrete low-level details on how memory works on the Parallella and Epiphany.
Next time I want to look the e-loader in more detail, and how programs start running on the cores.&lt;/p&gt;</description><category>epiphany</category><category>parallella</category><guid>https://markdewing.github.io/blog/posts/communicating-with-epiphany/</guid><pubDate>Tue, 25 Aug 2015 19:19:00 GMT</pubDate></item><item><title>Introduction to Parallella</title><link>https://markdewing.github.io/blog/posts/introduction-to-parallella/</link><dc:creator>Mark Dewing</dc:creator><description>&lt;p&gt;The Parallella is a single board computer with a dual core ARM and a 16 core Epiphany coprocessor. 
I've had some boards sitting around after backing the Kickstarter, and now I've finally started to play with them.&lt;/p&gt;
&lt;p&gt;The main purpose of the board is to highlight the Ephiphany coprocessor, but it has other interesting
resources as well.  I'd like to look into how to use each of them.&lt;/p&gt;
&lt;p&gt;Resources to program:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Xilinx Zynq (7010 or 7020), which contains&lt;ul&gt;
&lt;li&gt;dual core ARM Cortex A9 processors (with NEON SIMD instructions)&lt;/li&gt;
&lt;li&gt;FPGA&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Epiphany 16 core coprocessor (simple cores in a grid)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the website (&lt;a href="http://parallella.org"&gt;parallella.org&lt;/a&gt;) for more &lt;a href="http://parallella.org/board"&gt;details of the board&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;After getting the system set up and running according to the &lt;a href="https://www.parallella.org/quick-start/"&gt;directions&lt;/a&gt;, the first question is how 
to compile code?   Since there are two architectures on the board, it gets a bit more complex.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Regular PC (in my case, 64 bit, running Ubuntu) - the host for cross compilation, targeting either the ARM cores or the Epiphany.&lt;/li&gt;
&lt;li&gt;ARM on Zynq - can be a cross-compilation target, can compile for itself, or can compile for the Epiphany&lt;/li&gt;
&lt;li&gt;Epiphany - only a target&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While code can be compiled on the board, compiling on host PC can have some definite advantages with much larger resources of disk space, disk speed, etc.
However, setting up projects for cross-compiliation can be more challenging.&lt;/p&gt;
&lt;h2&gt;Cross compiling to ARM&lt;/h2&gt;
&lt;p&gt;On Ubuntu, this turns out to be fairly easy - the compiler packages that target ARM are already available in the repository.&lt;/p&gt;
&lt;p&gt;Using the Ubuntu Software Center (or Synaptic, or the apt- tools, as you prefer), install the following packages&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gcc-arm-linux-gnueabihf&lt;/li&gt;
&lt;li&gt;binutils-arm-linux-gnueabihf&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Selecting these should install the necessary dependencies (some listed here):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;libc6-armhf-cross&lt;/li&gt;
&lt;li&gt;libc6-dev-armhf-cross&lt;/li&gt;
&lt;li&gt;cpp-arm-linux-gnueabihf&lt;/li&gt;
&lt;li&gt;gcc-4.8-multilib-arm-linux-gnueabihf&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(By the way, the 'hf' at the end stands for 'Hard Float' - it means the processor has floating point in hardware)&lt;/p&gt;
&lt;p&gt;See this &lt;a href="https://parallella.org/forums/viewtopic.php?f=13&amp;amp;t=935"&gt;forum post&lt;/a&gt; for more information.  That post also contains instructions for setting up Eclipse (I'm more partial to the command line).&lt;/p&gt;
&lt;p&gt;To cross compile using the command line, all the normal compiler tools are prefixed with &lt;code&gt;arm-linux-gnueabihf&lt;/code&gt;.  Use &lt;code&gt;arm-linux-gnueabihf-gcc -o hello hello.c&lt;/code&gt; to compile a simple example.&lt;/p&gt;
&lt;p&gt;Run &lt;code&gt;file&lt;/code&gt; on the output file to verify it compiled as an ARM executable.&lt;/p&gt;
&lt;h3&gt;Clang&lt;/h3&gt;
&lt;p&gt;Compiling with clang needs at least the include and lib files from the 'libc6-*-armhf-cross' packages.&lt;/p&gt;
&lt;p&gt;Assuming the version of clang is built to output the 'arm' target, the following should work&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;clang&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;target&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arm&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;guneabihf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;I&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;arm&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;gnueabihf&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;hello&lt;/span&gt;.&lt;span class="nv"&gt;cpp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Cross compiling to Epiphany&lt;/h2&gt;
&lt;p&gt;These are the tools in the ESDK.&lt;/p&gt;
&lt;p&gt;If using the ARM as a host, the ESDK is already in the microSD images and the tools are in the path (&lt;code&gt;\opt\adapteva\esdk\tools\e-gnu\bin&lt;/code&gt;)
The tools are prefixed with &lt;code&gt;e-&lt;/code&gt;.  Use &lt;code&gt;e-gcc&lt;/code&gt; to invoke the compiler.&lt;/p&gt;
&lt;p&gt;For a Linux host, download and install the ESDK from the website (under &lt;code&gt;Software -&amp;gt; Pre-built -&amp;gt; Epiphany SDK&lt;/code&gt;)(&lt;a href="ftp://ftp.parallella.org/esdk"&gt;direct link&lt;/a&gt;).  Look for 'linux_x86_64' in the file name.&lt;/p&gt;
&lt;p&gt;The ESDK has examples you can compile and run.  Sometime later I want to take a closer look at how the Epiphany files are loaded to the coprocessor and run.&lt;/p&gt;</description><category>epiphany</category><category>parallella</category><category>zynq</category><guid>https://markdewing.github.io/blog/posts/introduction-to-parallella/</guid><pubDate>Thu, 20 Aug 2015 20:08:00 GMT</pubDate></item></channel></rss>