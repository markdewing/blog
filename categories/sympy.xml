<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Journey to the Center of the Computer (Posts about sympy)</title><link>https://markdewing.github.io/blog/</link><description></description><atom:link href="https://markdewing.github.io/blog/categories/sympy.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Fri, 26 Apr 2024 02:05:48 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Testing Scientific Software</title><link>https://markdewing.github.io/blog/posts/2024/testing-scientific-software/</link><dc:creator>Mark Dewing</dc:creator><description>&lt;p&gt;A perennial question when writing scientific code is how do you know the code is producing the right answer?&lt;/p&gt;
&lt;p&gt;This post describes the &lt;a href="https://github.com/QMCPACK/qmc_algorithms"&gt;QMC algorithms&lt;/a&gt; repository and testing in QMCPACK development to provide some answers this question.
QMCPACK implements Quantum Monte Carlo (QMC) methods for solving the Schödinger equation for atoms, molecules, and solids.&lt;/p&gt;
&lt;p&gt;The repository focuses on a few areas to contribute to testing and understanding scientific software:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Derived formulas using symbolic math&lt;/li&gt;
&lt;li&gt;Code generation from symbolic math&lt;/li&gt;
&lt;li&gt;Small problems with simple algorithms&lt;/li&gt;
&lt;li&gt;Reproduce and explain papers&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Another driving force in this work is that I have a strong conviction that symbolic mathematics is the most appropriate semantic level to describe scientific algorithms.
In this repository, Sympy is used for symbolic mathematics.&lt;/p&gt;
&lt;h3&gt;Deriving formulas&lt;/h3&gt;
&lt;p&gt;Some parts of scientific code are the final result of a series of derivation steps that are then
translated to code.  How do we know these steps are correct?  Especially the final step of math to code.
Usually these steps are all carried out by hand, with opportunities for errors to creep in.
We can use the computer to perform and check some of these steps.&lt;/p&gt;
&lt;h4&gt;Computing derivatives for comparisons&lt;/h4&gt;
&lt;p&gt;A Padé (rational function) form is the simplest functional form for a Jastrow factor, which describes electron-electron or electron-nucleus correlation in a wavefunction.
The &lt;a href="https://github.com/QMCPACK/qmc_algorithms/blob/master/Wavefunctions/Pade_Jastrow.ipynb"&gt;Pade_Jastrow.ipynb&lt;/a&gt; notebook simply expresses the form, computes some derivatives, and evaluates them at a particular value.&lt;/p&gt;
&lt;p&gt;The simplest way to use the results is to cut and paste the values from the notebook to the test case.
This gets tedious very quickly and is not easy to regenerate, especially when there are more
than a few values to copy.
It's straightforward to make a little template to output the values in a form
that is more directly usable in the test.&lt;/p&gt;
&lt;p&gt;For example, the following Python code will output a line suitable for use in a C++ unit test (with &lt;a href="https://github.com/catchorg/Catch2"&gt;Catch2&lt;/a&gt; assertions).&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;symbols&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'A B r'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sym_u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;
&lt;span class="n"&gt;val_u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;subs&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;0.25&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;'CHECK(u == Approx(&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;val_u&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s1"&gt;));'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;Other Derivations&lt;/h4&gt;
&lt;p&gt;There are a few types of splines used in QMCPACK.&lt;/p&gt;
&lt;p&gt;For &lt;a href="https://github.com/QMCPACK/qmc_algorithms/blob/master/Wavefunctions/Cubic%20Splines%20Basic.ipynb"&gt;cubic splines&lt;/a&gt;, the notebook sets up the equations based on constraints and boundary conditions.
It computes an example and solve the equations using a dense linear solver. (An example of using a simpler algorithm for validation.  The real code uses a more efficient tridiagonal solver.)
This gets incorporated into QMCPACK tests with the script &lt;a href="https://github.com/QMCPACK/qmcpack/blob/develop/src/Numerics/tests/gen_cubic_spline.py"&gt;gen_cubic_spline.py&lt;/a&gt; and the output of that script is in &lt;a href="https://github.com/QMCPACK/qmcpack/blob/develop/src/Numerics/tests/test_one_dim_cubic_spline.cpp"&gt;test_one_dim_cubic_spline.cpp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;B-splines are used in a one-dimensional form for Jastrow electron-electron and electron-ion correlation factors.
And also in a three-dimensional form for representing single-particle periodic orbitals.
They are much faster to evaluate than a plane wave representation.
The &lt;a href="https://github.com/QMCPACK/qmc_algorithms/blob/master/Wavefunctions/Explain_Bspline.ipynb"&gt;Explain_Bspline.ipnyb&lt;/a&gt; notebook starts from B-splines defined in Sympy and works through how they get used in QMCPACK.&lt;/p&gt;
&lt;h3&gt;Code generation&lt;/h3&gt;
&lt;p&gt;Code generation is used for the solver for the coefficients of cubic splines.
It starts from the tridiagonal matrix equations from Wikipedia, derives the cubic spline equations (same as previously), combines the two and outputs the resulting algorithm to C++ code.&lt;/p&gt;
&lt;p&gt;The notebook is &lt;a href="https://github.com/QMCPACK/qmc_algorithms/blob/master/Wavefunctions/CubicSplineSolver.ipynb"&gt;CubicSplineSolver.ipynb&lt;/a&gt;.
The corresponding script in QMCPACK is &lt;a href="https://github.com/QMCPACK/qmcpack/blob/develop/src/Numerics/codegen/gen_cubic_spline_solver.py"&gt;gen_cubic_spline_solver.py&lt;/a&gt;.
The generated spline solver is located in &lt;a href="https://github.com/QMCPACK/qmcpack/blob/develop/src/Numerics/SplineSolvers.h"&gt;SplineSolvers.h&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Some simpler code generation in the QMCPACK repository involves the angular part of atomic orbitals.&lt;br&gt;
There is a notebook about &lt;a href="https://github.com/QMCPACK/qmc_algorithms/blob/master/Wavefunctions/GaussianOrbitals.ipynb"&gt;Gaussian orbitals&lt;/a&gt;.
In this case, the starting expression is simple and computing the various derivatives is tedious
and the script in QMCPACK, &lt;a href="https://github.com/QMCPACK/qmcpack/blob/develop/src/Numerics/codegen/gen_cartesian_tensor.py"&gt;gen_cartesian_tensor.py&lt;/a&gt;, takes care of that part.&lt;/p&gt;
&lt;h3&gt;Simple algorithms&lt;/h3&gt;
&lt;p&gt;Some ways to obtain reference values for test cases include special cases that have analytic solutions
and small problems that can be solved using an alternative method that is easier to understand and verify than the implemented algorithm.&lt;/p&gt;
&lt;p&gt;Computing long-range sums of periodic Coulomb potentials requires some tricks to ensure convergence.
The Ewald method splits the sum in two pieces and uses the Fourier transform of the long-range part for faster convergence. It is implemented in a simple Python script, &lt;a href="https://github.com/QMCPACK/qmc_algorithms/blob/master/LongRange/ewald_sum.py"&gt;ewald_sum.py&lt;/a&gt;, which can be used to verify more sophisticated splits of the sum used in the code.&lt;/p&gt;
&lt;p&gt;For the Schrödinger equation, an exact analytic solution is known for the hydrogen atom.
A deliberately incorrect wavefunction is used as a trial wavefunction in &lt;a href="https://github.com/QMCPACK/qmc_algorithms/blob/master/Variational/Variational_Hydrogen.ipynb"&gt;Variational_Hydrogen.ipynb&lt;/a&gt; to demonstrate the variational principle.&lt;/p&gt;
&lt;p&gt;A slightly larger problem is that of a helium atom.
The ground state wavefunction for a helium atom does not have an analytic solution and is the simplest example involving electron-electron correlation.
The notebook &lt;a href="https://github.com/QMCPACK/qmc_algorithms/blob/master/Variational/Variational_Helium.ipynb"&gt;Variational_Helium.ipynb&lt;/a&gt; uses symbolic means to find the derivatives of the local
energy, and grid-based integration instead of Monte Carlo.
(The details of the integration are discussed &lt;a href="https://markdewing.github.io/blog/posts/integration-callbacks/"&gt;here&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;Another approach to the derivatives is autodifferentiation.
There is a minimal QMC code used for creating reference values, particular for derivatives of variational parameters and orbital rotation.
It uses the &lt;a href="https://github.com/HIPS/autograd"&gt;autograd&lt;/a&gt; package for differentiation.
The QMC loop is in &lt;a href="https://github.com/QMCPACK/qmcpack/blob/develop/src/QMCWaveFunctions/tests/run_qmc.py"&gt;run_qmc.py&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The target systems are:
* Helium atom in &lt;a href="https://github.com/QMCPACK/qmcpack/blob/develop/src/QMCWaveFunctions/tests/gen_rotated_lcao_wf.py"&gt;gen_rotated_lcao_wf.py&lt;/a&gt;
* Beryllium atom in &lt;a href="https://github.com/QMCPACK/qmcpack/blob/develop/src/QMCWaveFunctions/tests/rot_be_sto_wf.py"&gt;rot_be_sto_wf.py&lt;/a&gt;
* Beryllium atom with two determinants in &lt;a href="https://github.com/QMCPACK/qmcpack/blob/develop/src/QMCWaveFunctions/tests/rot_multi_be_sto_wf.py"&gt;rot_multi_be_sto_wf.py&lt;/a&gt;
* Solid Beryllium with a psuedopotential in &lt;a href="https://github.com/QMCPACK/qmcpack/blob/develop/src/QMCWaveFunctions/tests/eval_bspline_spo.py"&gt;eval_bspline_spo.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(To improve on the performance of run_qmc.py and related scripts, I wrote a version using the multiprocessing package in Python. For even more performance, there is a port of these scripts to Julia.)&lt;/p&gt;
&lt;h3&gt;Reproduce and explain papers&lt;/h3&gt;
&lt;p&gt;Published papers contain derivations that leave intermediate steps as an exercise for the reader 
should they want to reproduce or implement the described algorithm.&lt;/p&gt;
&lt;p&gt;There is a nice writeup, contributed by Andrew Baczewski, to explain and reproduce a paper &lt;a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.30.2713"&gt;"Observations on the statistical iteration of matrices"&lt;/a&gt;
in this notebook
&lt;a href="https://github.com/QMCPACK/qmc_algorithms/blob/master/StochasticReconfiguration/Reproduce_Hetherington_PRA1984.ipynb"&gt;Reproduce Hetherington PRA1984.ipynb&lt;/a&gt;
The paper describes a stochastic reconfiguration method for controlling variance and bias in a Monte Carlo simulation.&lt;/p&gt;
&lt;p&gt;Another example involves a cusp correction scheme, which adds some modifications to Gaussian-type orbitals
commonly used in quantum chemistry to work better for a Quantum Monte Carlo wavefunction.
It comes from the paper 
&lt;a href="https://doi.org/10.1063/1.1940588"&gt;Scheme for adding electron-nucleus cusps to Gaussian orbitals&lt;/a&gt;.
The notebook
&lt;a href="https://github.com/QMCPACK/qmc_algorithms/blob/master/Wavefunctions/CuspCorrection.ipynb"&gt;CuspCorrection.ipynb&lt;/a&gt;
follows through solving some polynomial equations and presents some examples.
The script used to generate reference values for tests in QMCPACK is &lt;a href="https://github.com/QMCPACK/qmcpack/blob/develop/src/QMCWaveFunctions/tests/gen_cusp_corr.py"&gt;gen_cusp_corr.py&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The process for using notebooks is
1. Jupyter notebook provides exposition of an algorithm or concept.
2. The code gets copied to a script in the appropriate test directory in the
QMCPACK repository, and that location is the code that produces the results for the QMCPACK tests.&lt;/p&gt;
&lt;p&gt;This does result in duplication of code, but at least the scripts and tests in the QMCPACK repository are self-contained.&lt;/p&gt;
&lt;h3&gt;Final thoughts&lt;/h3&gt;
&lt;p&gt;This post described several techniques for testing scientific software.&lt;/p&gt;
&lt;p&gt;One of the important aspects of learning is working with the material and wrestling with it.
At some point, you have to do the derivation yourself in order to learn it.
These notebooks are a record of my approach to exploring these topics.
Are these useful to anyone else? Could they be made more useful?&lt;/p&gt;
&lt;p&gt;The descriptions in many of the notebooks are very short and could be expanded.
What would make them more useful?  For someone trying to understand
the code?  Or for someone trying to reproduce and extend the work?&lt;/p&gt;</description><category>python</category><category>sympy</category><category>testing</category><guid>https://markdewing.github.io/blog/posts/2024/testing-scientific-software/</guid><pubDate>Thu, 25 Apr 2024 16:20:00 GMT</pubDate></item><item><title>Integration Callbacks with Sympy and LLVM</title><link>https://markdewing.github.io/blog/posts/integration-callbacks/</link><dc:creator>Mark Dewing</dc:creator><description>&lt;p&gt;This post explores various packages for multi-dimensional integration along with
generating callbacks for the integrands from Sympy using an LLVM JIT&lt;/p&gt;
&lt;h3&gt;Problem to integrate&lt;/h3&gt;
&lt;p&gt;The particular problem is using the variational principle to find the ground state energy for atoms.
Some Jupyter notebooks with a description of the problem, along with various integration methods:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/markdewing/next_steps_in_programming/blob/master/examples/integration/Hydogen%20Atom.ipynb"&gt;Ground state energy of Hydrogen Atom&lt;/a&gt;   (This yields a 3 dimensional integral.)&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/markdewing/next_steps_in_programming/blob/master/examples/integration/Helium%20atom.ipynb"&gt;Ground state energy of Helium Atom&lt;/a&gt;  (This yields a 6 dimensional integral.)&lt;/p&gt;
&lt;p&gt;The standard solution to these integrals is to use Markov Chain Monte Carlo (the Quantum Monte Carlo method).&lt;br&gt;
However, I'm curious to see how far alternate integration schemes or existing integration packages would work.&lt;/p&gt;
&lt;h3&gt;Integration libraries&lt;/h3&gt;
&lt;p&gt;The &lt;a href="http://docs.scipy.org/doc/scipy/reference/tutorial/integrate.html"&gt;scipy quadrature&lt;/a&gt; routines accept a natively compiled callback for the integrand. 
(Noticing this in the documentation initiated the idea for using JIT compilation for callback functions.)&lt;/p&gt;
&lt;p&gt;Next up is the &lt;a href="http://ab-initio.mit.edu/wiki/index.php/Cubature"&gt;Cubature&lt;/a&gt; integration package, with the &lt;a href="https://github.com/saullocastro/cubature"&gt;Python wrapper for cubature&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Finally is the &lt;a href="http://www.feynarts.de/cuba/"&gt;Cuba&lt;/a&gt; library, with the PyCuba interface (part of the &lt;a href="https://github.com/JohannesBuchner/PyMultiNest"&gt;PyMultiNest&lt;/a&gt; package)&lt;/p&gt;
&lt;p&gt;There are some other libraries such at &lt;a href="http://mint.sbg.ac.at/HIntLib/"&gt;HIntLib&lt;/a&gt; that I would also like to try.  There doesn't seem to be a python interface for HIntLib.  Let me know if there is one somewhere. And if there are other multidimensional integration packages to try.&lt;/p&gt;
&lt;h3&gt;Evaluating the integrand&lt;/h3&gt;
&lt;p&gt;One of my scientific programming goals is to generate efficient code from a symbolic expression.
To this end, I've been working on an LLVM JIT converter for Sympy expressions (using the &lt;a href="https://github.com/numba/llvmlite"&gt;llvmlite&lt;/a&gt; wrapper).&lt;/p&gt;
&lt;p&gt;For the Sympy code, see these pull requests: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/sympy/sympy/pull/10451"&gt;Create executable functions from Sympy expressions&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/sympy/sympy/pull/10640"&gt;Accelerated callbacks for integration routines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/sympy/sympy/pull/10683"&gt;JIT - handle multiple expressions (as returned from CSE)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/sympy/sympy/pull/11057"&gt;Add LLVM JIT callbacks for PyCuba integration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As an aside, one can question if is this the right approach, compared with&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Generate C++ or Fortran and compile using the existing autowrap functionality in Sympy.&lt;/li&gt;
&lt;li&gt;Generate Python/Numpy and use Numba.&lt;/li&gt;
&lt;li&gt;Use Julia&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There is always a tradeoff between a narrow, specialized solution, which is faster to implement and
perhaps easier to understand, and a more general solution, which applies in more cases, but is
harder and slower to implement.&lt;/p&gt;
&lt;p&gt;Using an LLVM JIT is a specialized solution, but it does have an advantage that there is a short path from the expressions to the compiled code.
One disadvantage is that it does not leverage existing compilers (Numba or C++), though LLVM compiler optimization passes are available.&lt;/p&gt;
&lt;p&gt;Sometimes a solution just needs to be tried to gain experience with the advantages and drawbacks.&lt;/p&gt;
&lt;h3&gt;Results&lt;/h3&gt;
&lt;p&gt;For the helium atom, the integration times are reported in the table below&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left;"&gt;Integrator  &lt;/th&gt;
&lt;th style="text-align: right;"&gt;Time (seconds)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Cubature&lt;/td&gt;
&lt;td style="text-align: right;"&gt;171&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Cubature w/CSE&lt;/td&gt;
&lt;td style="text-align: right;"&gt;141&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Cubature w/CSE and multiple evals&lt;/td&gt;
&lt;td style="text-align: right;"&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Cuba (Vegas)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;29&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Cuba (Cuhre)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;22&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Note that &lt;code&gt;scipy.nquad&lt;/code&gt; was not used for the 6D integral. It quickly runs out of steam because it consists of iterated one dimensional integrations, and the glue between the dimensions goes through Python, reducing the effectiveness of a compiled integrand.&lt;/p&gt;
&lt;p&gt;The Cubature library does better.  Profiling shows that most of the time is spent internal to cubature and allocating memory, so faster integrand evaluation is not going to improve the time.
Some other approaches can help.  One is Common Subexpression Elimination (CSE), which Sympy can perform on the expression.  This extracts duplicate fragments so their value only needs to be computed once.&lt;/p&gt;
&lt;p&gt;The library also allows multiple integrals to be performed at once.   This can amortize some of the overhead of the library.  In this case, the individual calls to integrator for the numerator and denominator can be reduced to a single call.&lt;/p&gt;
&lt;p&gt;The Cuba library performs even better, as there is apparently less overhead inside the integration library.  The Cuhre integrator uses a deterministic grid-based algorithm similar to Cubature.  Vegas uses an adaptive Monte Carlo approach.&lt;/p&gt;
&lt;p&gt;The results are not shown here, but I also used SIMD vectorization to make the function evaluation even faster, which succeeded for the bare function evaluation. (This was one of the original motivations for compiling straight to LLVM, as it would be easier to get vectorization working.)
 Unfortunately, it did not speed up the overall integration much (if at all), due to overhead in the libraries.&lt;/p&gt;
&lt;h3&gt;Conclusions and future work&lt;/h3&gt;
&lt;p&gt;Using an LLVM JIT to create callbacks for integration works fairly well.&lt;/p&gt;
&lt;p&gt;One important question is how to scale the creation of the callbacks to new libraries without explicitly programming them into Sympy.&lt;br&gt;
The &lt;a href="https://github.com/sympy/sympy/pull/11057"&gt;last pull request&lt;/a&gt; has expanded the &lt;code&gt;CodeSignature&lt;/code&gt; class, which seems like  a starting point for such a more general callback specification.&lt;/p&gt;</description><category>cubature</category><category>integration</category><category>llvm</category><category>sympy</category><guid>https://markdewing.github.io/blog/posts/integration-callbacks/</guid><pubDate>Fri, 08 Jul 2016 21:37:00 GMT</pubDate></item></channel></rss>