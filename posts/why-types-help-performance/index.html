<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Why Types Help Performance | Journey to the Center of the Computer</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../rss.xml">
<link rel="canonical" href="https://markdewing.github.io/blog/posts/why-types-help-performance/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Mark Dewing">
<link rel="prev" href="../first-performance-improvements/" title="First Performance Improvements" type="text/html">
<link rel="next" href="../two-meanings-of-vectorization/" title="Two Meanings of Vectorization" type="text/html">
<meta property="og:site_name" content="Journey to the Center of the Computer">
<meta property="og:title" content="Why Types Help Performance">
<meta property="og:url" content="https://markdewing.github.io/blog/posts/why-types-help-performance/">
<meta property="og:description" content="In previous posts, we've seen that adding type information can help the performance of the code generated by dynamic language compilers.
The documentation for Cython annotations talks of 'Python inter">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2015-09-24T10:48:00-05:00">
<meta property="article:tag" content="cython">
<meta property="article:tag" content="julia">
<meta property="article:tag" content="Numba">
<meta property="article:tag" content="python">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-expand-md static-top mb-4
navbar-dark
bg-dark
"><div class="container">
<!-- This keeps the margins nice -->
        <a class="navbar-brand" href="../../">

            <span id="blog-title">Journey to the Center of the Computer</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="../../archive.html" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="../../categories/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="../../rss.xml" class="nav-link">RSS feed</a>

                
            </li>
</ul>
<ul class="navbar-nav navbar-right">
<li class="nav-item">
    <a href="index.md" id="sourcelink" class="nav-link">Source</a>
    </li>


                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Why Types Help Performance</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Mark Dewing
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2015-09-24T10:48:00-05:00" itemprop="datePublished" title="2015-09-24 10:48">2015-09-24 10:48</time></a>
            </p>
                <p class="commentline">
    
    <a href="#disqus_thread" data-disqus-identifier="cache/posts/why-types-help-performance.html">Comments</a>


            
        </p>
<p class="sourceline"><a href="index.md" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>In <a href="http://markdewing.github.io/blog/posts/first-performance-improvements">previous</a> <a href="http://markdewing.github.io/blog/posts/comparing-languages-with-miniapps/">posts</a>, we've seen that adding type information can help the performance of the code generated by dynamic language compilers.
The documentation for Cython annotations talks of 'Python interaction', and Numba has 'object' mode and 'nopython' modes.
In post I will look more at what these mean, and how they affect performance.</p>
<p>To start, consider how values are represented in a computer, such as a simple integer ('int' type in C).
The bare value takes 4 bytes in memory, and no additional information about it is stored,
such as its type or how much space it occupies.
This information is all implicit at run time <sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>.
That it takes 4-bytes and is interpreted as an integer is determined at compile time.</p>
<p>In dynamic languages, this extra information can be queried at run-time.
For example:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&lt;</span><span class="nb">type</span> <span class="s1">'int'</span><span class="o">&gt;</span>
</pre></div>

<p>The value stored in <code>a</code> has type <code>int</code>, Python's integer type.
This extra information must be stored somewhere, and languages often solve this by wrapping
the bare value in an object.
This is usually called 'boxing'.
The value plus type information (and any other information) is called a 'boxed type'.
The bare value is called an 'unboxed type' or a 'primitive value'.</p>
<p>In Java, different types can be explicitly created (<code>int</code> vs. <code>Integer</code>), and the programmer
needs to know the differences and tradeoffs.
(See this <a href="http://stackoverflow.com/questions/13055/what-is-boxing-and-unboxing-and-what-are-the-trade-offs">Stack Overflow question</a> for more about boxed and primitive types.)</p>
<p>Python only has boxed values ('everything is an object'). From the interpreter, this means we can
always determine the type of a value.
If we look a layer down, as would be needed to integrate with C, these values are accessed through the Python API.
The base type of any object is PyObject.  For our simple example, integers are stored as PyIntObject.</p>
<p>For example, consider the following Python code.</p>
<div class="code"><pre class="code literal-block">  <span class="k">def</span> <span class="nf">add</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>

<p>One way to see what calls the interpreter would make is to compile with Cython.
The following C is the result (simplified - reference counting pieces to the Python API are omitted.)</p>
<div class="code"><pre class="code literal-block"><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">add</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">pyx_int_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInt_FromLong</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">pyx_int_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInt_FromLong</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">  </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">pyx_tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyNumber_Add</span><span class="p">(</span><span class="n">pyx_int_1</span><span class="p">,</span><span class="w"> </span><span class="n">pyx_int_2</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">pyx_tmp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>Without type information, Cython basically unrolls the interpreter loop, and makes
a sequence of Python API calls.
The HTML annotation output highlights lines with Python interaction, and can be expanded to show
the generated code.   This gives feedback on where and what types need to be added to avoid
the Python API calls.</p>
<p>Add some Cython annotations and the example becomes</p>
<div class="code"><pre class="code literal-block"> <span class="n">cdef</span> <span class="nb">int</span> <span class="n">add</span><span class="p">():</span>
    <span class="n">cdef</span> <span class="nb">int</span> <span class="n">a</span>
    <span class="n">cdef</span> <span class="nb">int</span> <span class="n">b</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>

<p>Now the following code is generated</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">add</span><span class="p">()</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>

<p>The add of the two integers is done directly (and runs much faster), rather than going through the Python API call.</p>
<h3>Numba</h3>
<p>If its type information is insufficient, Numba will call the Python API for every operation.
Since all the operations occur on Python objects, this is called 'object' mode (slow).
With sufficient type information, code can be generated with no calls to the Python API, and hence
the name 'nopython' mode (fast).</p>
<h3>Julia</h3>
<p>Julia has boxed object types, but is designed to try use the unboxed types as much as possible.
The most generic type is called 'Any', and it is possible to produce Julia code that runs this mode.<br>
See the section on <a href="http://julia.readthedocs.org/en/latest/manual/embedding/">Embedding Julia</a> in the
documentation for more about Julia objects.</p>
<p>Julia's type inference only happens inside functions.
This is why composite types (structures) need type annotations for good performance.</p>
<p>This example demonstrates the issue</p>
<div class="code"><pre class="code literal-block"><span class="n">type</span><span class="w"> </span><span class="n">Example</span>
<span class="w">    </span><span class="n">val</span>
<span class="k">end</span>

<span class="k">function</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="n">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="n">val</span>
<span class="k">end</span>

<span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Example</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Example</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="nd">@code_llvm</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w">  </span><span class="c"># The @code_llvm macro prints the LLVM IR.  </span>
<span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="s">"res = "</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
</pre></div>

<p>Since the type of the 'val' element is not known, the code operates on a generic object type <code>jl_value_t</code> and eventually calls <code>jl_apply_generic</code>, which looks up the right method and dispatches to it at execution time.
(The LLVM IR is not shown here - run the example to see it.)  Doing all this at execution time is slow.</p>
<p>Now add the type annotation</p>
<div class="code"><pre class="code literal-block"><span class="n">type</span><span class="w"> </span><span class="n">Example</span>
<span class="w">    </span><span class="n">val</span><span class="o">::</span><span class="kt">Int</span>
<span class="k">end</span>
</pre></div>

<p>The resulting LLVM IR (also not shown here) is much shorter in that it adds two integers directly and
returns the result as an integer.
With type information, the lookup and dispatch decisions can be made at compile time.</p>
<p>Note that Julia uses a Just In Time (JIT) compiler, which means compilation occurs at run time.
The run time can be split into various phases, which include compilation and execution of
the resulting code.</p>
<h3>Summary</h3>
<p>Hopefully this post sheds some light on how type information can affect the performance of dynamic languages.</p>
<div class="footnote">
<hr>
<ol>
<li id="fn:1">
<p>The type can be accessible at run time via debug information.  See this Strange Loop 2014 talk: <a href="https://www.youtube.com/watch?v=LwicN2u6Dro">Liberating the lurking Smalltalk in Unix</a> <a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
</ol>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/cython/" rel="tag">cython</a></li>
            <li><a class="tag p-category" href="../../categories/julia/" rel="tag">julia</a></li>
            <li><a class="tag p-category" href="../../categories/numba/" rel="tag">Numba</a></li>
            <li><a class="tag p-category" href="../../categories/python/" rel="tag">python</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../first-performance-improvements/" rel="prev" title="First Performance Improvements">Previous post</a>
            </li>
            <li class="next">
                <a href="../two-meanings-of-vectorization/" rel="next" title="Two Meanings of Vectorization">Next post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
        
    
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="journeytothecenterofthecomputer",
            disqus_url="https://markdewing.github.io/blog/posts/why-types-help-performance/",
        disqus_title="Why Types Help Performance",
        disqus_identifier="cache/posts/why-types-help-performance.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        </section></article><script>var disqus_shortname="journeytothecenterofthecomputer";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script><!--End of body content--><footer id="footer">
            Contents © 2023         <a href="mailto:markdewing%20(at)%20gmail%20(dot)%20com">Mark Dewing</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
